/*
 * Author:  Justin Nguyen
 * Created: 7/29/2016
 */

1. Operators are implemented as functions
    --> so we can function overload them as well
    --> this is called "operator overloading"

2. What arithmetic actually looks like
    --> int x; int y;
        x = y --> operator+(x, y)

3. Rules for resolving overloaded operators
    --> A) all operands are primitives --> call built-in operator fxn
    --> B) any operands are not primitives
            --> checks for a matching overloaded operator function
            --> if none, tries overloaded typcast conversion
            --> if that fails, throws a compiler error

4. Limitations for operator overloading
    --> A) operators ?, sizeof, ::, ., .*
    --> B) cannot create operators that don't exist
    --> C) at least one of the operands has to be a user-defined type
           (e.g. adding an int and a double does not work)
    --> D) cannot change the number of operands for an operator
    --> E) cannot change operator precedence and associativity

5. Using a named function or overloading an operator?
    --> Operators are not named and their use can therefore be unclear
    --> operator+() for the string class obviously means concatentation
        operator-() for the string class is unclear
    --> use a named function instead

6. Good operators to overload in general
    --> the (+) operator, (<<) operator, (==) operator
    --> addition, printing, comparison

7. Overloading using friend functions
    --> class Cents { friend Cents operator+(Cents& c1, Cents& c2); }

8. Overloading operators when the operands are different types
    --> operator+(Cents, int)   and   operator+(int, Cents)
    --> have to write two functions to overload the operators

    MinMax operator+(const MinMax &m, int value) {
        int min = m.m_min < value ? m.m_min : value;
        int max = m.m_max > value ? m.m_max : value;
        return MinMax(min, max);
    }

    MinMax operator+(int value, const MinMax &m) {
        return (m + value);
    }

9. Overloading output operator
    --> different because you return a reference to an ostream object
    --> do this to let you chain output commands
    --> example:
        friend std::ostream& operator<< (std::ostream& cout, const Point& p);

10. Overloading input operator
    --> return a reference to an istream object, can still chain
    --> don't make the Point object const because
        you need to change the object's members
    --> example:
        friend std::istream& operator>> (std::istream& cin, Point& p);
        std::istream& operator>> (std::istream& cin, Point& p) {
            cin >> p.x; cin >> p.y; cin >> p.z;
        }

11. Overloading using member functions

    --> three things to be aware of
    --> 1. The overloaded operator must be added as 
           a member function of the left operand.
    --> 2. The left operand becomes the implicit *this object
    --> 3. All other operands become function parameters.

    --> three things change
    --> 1. The overloaded operator is defined as a member instead of a friend 
           (Cents::operator+ instead of friend operator+)
    --> 2. The left param is removed because it becomes the implicit *this object
    --> 3. Inside the function body, all references to the left parameter can 
           be removed (e.g. cents.m_cents becomes m_cents)
    
    Cents operator+(int value);
    Cents Cents::operator+(int value) {
        return Cents(m_cents + value);
    }
    
    In the friend function version, the expression cents1 + 2 becomes the
    function call operator+(cents1, 2). Note that there are two function parameters.

    In the member function version, the expression cents1 + 2 becomes the 
    function call cents1.operator+(2). Note that there is now only 
    one explicit function parameter, and cents1 has become an object prefix. 
    
12. Which one to use? Member or Friend?
    --> If overloading the assignment operator (=), subscript operator ([]), 
        function call operator (()), or member selection operator (->), 
        --> member function
    --> If overloading a unary operator
        --> member function
    --> If overloading a binary operator that modifies its left operand (e.g. operator+=)
        --> member function
    --> If overloading a binary operator that does not modify its left operand (e.g. operator+)
        --> normal function or friend function
        --> e.g. output operator (<<) and when left operand is an unmodifiable class (int, etc.)

13. Overloading unary operators
    --> don't forget to make them const
    --> Point Point::operator- () const {
            return Point(-m_x, -m_y, -m_z);
        }

