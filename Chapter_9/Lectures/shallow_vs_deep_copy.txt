/*
 * Author:  Justin Nguyen
 * Created: 8/5/2016
 */
 
1. Shallow Copying
    --> when the members are copied verbatim
    --> dangerous when dealing with dynamic memory
        --> copies will copy the address held by the pointer
            (no additional memory is allocated)
            (so now we have two pointers to the same data)
            
2. This will break
    --> int main() {
            MyString hello("Hello, world!");
            
            {
                MyString copy = hello; // use default copy constructor
            } // copy gets destroyed here
         
            std::cout << hello.getString() << '\n'; // breaks here
        }
    
    --> once copy goes out of scope due to the braces,
        the pointers will be deleted so we are left with
        hello.m_data being a dangling pointer
        
3. Deep Copying
    --> copies the values such that the copy lies in a
        different memory location from the original
    --> need to 
        --> check if the original is null,
        --> allocate memory for the copy
        --> copy the values over one at a time
    --> example of copy constructor using a deep copy
    
        MyString::MyString(const MyString& str) {
            m_length = str.m_length;
            
            if (str.m_data) {
                m_data = new char[m_length];
                
                for (int i = 0; i < m_length; ++i) {
                    m_data[i] = str.m_data[i];
                }
            } else {
                m_data = 0;
            }
        }

